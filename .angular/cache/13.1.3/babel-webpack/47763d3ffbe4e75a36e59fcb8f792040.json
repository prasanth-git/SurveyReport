{"ast":null,"code":"import { ActiveDescendantKeyManager } from '@angular/cdk/a11y';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { InjectionToken, EventEmitter, Component, ViewEncapsulation, ChangeDetectionStrategy, ChangeDetectorRef, ElementRef, Inject, ViewChild, TemplateRef, ContentChildren, Input, Output, Directive, forwardRef, ViewContainerRef, NgZone, Optional, Host, NgModule } from '@angular/core';\nimport { mixinDisableRipple, MAT_OPTION_PARENT_COMPONENT, MatOption, MatOptgroup, MatOptionSelectionChange, _countGroupLabelsBeforeOption, _getOptionScrollPosition, MatOptionModule, MatCommonModule } from '@angular/material/core';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport { Overlay, OverlayConfig, OverlayModule } from '@angular/cdk/overlay';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { ESCAPE, ENTER, UP_ARROW, DOWN_ARROW, TAB } from '@angular/cdk/keycodes';\nimport { _supportsShadowDom } from '@angular/cdk/platform';\nimport { TemplatePortal } from '@angular/cdk/portal';\nimport { ViewportRuler } from '@angular/cdk/scrolling';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { MatFormField } from '@angular/material/form-field';\nimport { Subscription, Subject, defer, merge, of, fromEvent } from 'rxjs';\nimport { take, switchMap, filter, map, tap, delay } from 'rxjs/operators';\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/autocomplete/autocomplete.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Autocomplete IDs need to be unique across components, so this counter exists outside of\n * the component definition.\n * @type {?}\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\nimport * as ɵngcc2 from '@angular/cdk/overlay';\nimport * as ɵngcc3 from '@angular/cdk/bidi';\nimport * as ɵngcc4 from '@angular/material/form-field';\nimport * as ɵngcc5 from '@angular/cdk/scrolling';\nconst _c0 = [\"panel\"];\n\nfunction MatAutocomplete_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"div\", 0, 1);\n    ɵngcc0.ɵɵprojection(2);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"id\", ctx_r0.id)(\"ngClass\", ctx_r0._classList);\n  }\n}\n\nconst _c1 = [\"*\"];\nlet _uniqueAutocompleteIdCounter = 0;\n/**\n * Event object that is emitted when an autocomplete option is selected.\n */\n\nclass MatAutocompleteSelectedEvent {\n  /**\n   * @param {?} source\n   * @param {?} option\n   */\n  constructor(source, option) {\n    this.source = source;\n    this.option = option;\n  }\n\n}\n\nif (false) {\n  /**\n   * Reference to the autocomplete panel that emitted the event.\n   * @type {?}\n   */\n  MatAutocompleteSelectedEvent.prototype.source;\n  /**\n   * Option that was selected.\n   * @type {?}\n   */\n\n  MatAutocompleteSelectedEvent.prototype.option;\n} // Boilerplate for applying mixins to MatAutocomplete.\n\n/**\n * \\@docs-private\n */\n\n\nclass MatAutocompleteBase {}\n/** @type {?} */\n\n\nconst _MatAutocompleteMixinBase = /*#__PURE__*/mixinDisableRipple(MatAutocompleteBase);\n/**\n * Default `mat-autocomplete` options that can be overridden.\n * @record\n */\n\n\nfunction MatAutocompleteDefaultOptions() {}\n\nif (false) {\n  /**\n   * Whether the first option should be highlighted when an autocomplete panel is opened.\n   * @type {?|undefined}\n   */\n  MatAutocompleteDefaultOptions.prototype.autoActiveFirstOption;\n}\n/**\n * Injection token to be used to override the default options for `mat-autocomplete`.\n * @type {?}\n */\n\n\nconst MAT_AUTOCOMPLETE_DEFAULT_OPTIONS = /*#__PURE__*/new InjectionToken('mat-autocomplete-default-options', {\n  providedIn: 'root',\n  factory: MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY\n});\n/**\n * \\@docs-private\n * @return {?}\n */\n\nfunction MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY() {\n  return {\n    autoActiveFirstOption: false\n  };\n}\n\nlet MatAutocomplete = /*#__PURE__*/(() => {\n  class MatAutocomplete extends _MatAutocompleteMixinBase {\n    /**\n     * @param {?} _changeDetectorRef\n     * @param {?} _elementRef\n     * @param {?} defaults\n     */\n    constructor(_changeDetectorRef, _elementRef, defaults) {\n      super();\n      this._changeDetectorRef = _changeDetectorRef;\n      this._elementRef = _elementRef;\n      /**\n       * Whether the autocomplete panel should be visible, depending on option length.\n       */\n\n      this.showPanel = false;\n      this._isOpen = false;\n      /**\n       * Function that maps an option's control value to its display value in the trigger.\n       */\n\n      this.displayWith = null;\n      /**\n       * Event that is emitted whenever an option from the list is selected.\n       */\n\n      this.optionSelected = new EventEmitter();\n      /**\n       * Event that is emitted when the autocomplete panel is opened.\n       */\n\n      this.opened = new EventEmitter();\n      /**\n       * Event that is emitted when the autocomplete panel is closed.\n       */\n\n      this.closed = new EventEmitter();\n      this._classList = {};\n      /**\n       * Unique ID to be used by autocomplete trigger's \"aria-owns\" property.\n       */\n\n      this.id = `mat-autocomplete-${_uniqueAutocompleteIdCounter++}`;\n      this._autoActiveFirstOption = !!defaults.autoActiveFirstOption;\n    }\n    /**\n     * Whether the autocomplete panel is open.\n     * @return {?}\n     */\n\n\n    get isOpen() {\n      return this._isOpen && this.showPanel;\n    }\n    /**\n     * Whether the first option should be highlighted when the autocomplete panel is opened.\n     * Can be configured globally through the `MAT_AUTOCOMPLETE_DEFAULT_OPTIONS` token.\n     * @return {?}\n     */\n\n\n    get autoActiveFirstOption() {\n      return this._autoActiveFirstOption;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set autoActiveFirstOption(value) {\n      this._autoActiveFirstOption = coerceBooleanProperty(value);\n    }\n    /**\n     * Takes classes set on the host mat-autocomplete element and applies them to the panel\n     * inside the overlay container to allow for easy styling.\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set classList(value) {\n      if (value && value.length) {\n        this._classList = value.split(' ').reduce(\n        /**\n        * @param {?} classList\n        * @param {?} className\n        * @return {?}\n        */\n        (classList, className) => {\n          classList[className.trim()] = true;\n          return classList;\n        },\n        /** @type {?} */\n        {});\n      } else {\n        this._classList = {};\n      }\n\n      this._setVisibilityClasses(this._classList);\n\n      this._elementRef.nativeElement.className = '';\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngAfterContentInit() {\n      this._keyManager = new ActiveDescendantKeyManager(this.options).withWrap(); // Set the initial visibility state.\n\n      this._setVisibility();\n    }\n    /**\n     * Sets the panel scrollTop. This allows us to manually scroll to display options\n     * above or below the fold, as they are not actually being focused when active.\n     * @param {?} scrollTop\n     * @return {?}\n     */\n\n\n    _setScrollTop(scrollTop) {\n      if (this.panel) {\n        this.panel.nativeElement.scrollTop = scrollTop;\n      }\n    }\n    /**\n     * Returns the panel's scrollTop.\n     * @return {?}\n     */\n\n\n    _getScrollTop() {\n      return this.panel ? this.panel.nativeElement.scrollTop : 0;\n    }\n    /**\n     * Panel should hide itself when the option list is empty.\n     * @return {?}\n     */\n\n\n    _setVisibility() {\n      this.showPanel = !!this.options.length;\n\n      this._setVisibilityClasses(this._classList);\n\n      this._changeDetectorRef.markForCheck();\n    }\n    /**\n     * Emits the `select` event.\n     * @param {?} option\n     * @return {?}\n     */\n\n\n    _emitSelectEvent(option) {\n      /** @type {?} */\n      const event = new MatAutocompleteSelectedEvent(this, option);\n      this.optionSelected.emit(event);\n    }\n    /**\n     * Sets the autocomplete visibility classes on a classlist based on the panel is visible.\n     * @private\n     * @param {?} classList\n     * @return {?}\n     */\n\n\n    _setVisibilityClasses(classList) {\n      classList['mat-autocomplete-visible'] = this.showPanel;\n      classList['mat-autocomplete-hidden'] = !this.showPanel;\n    }\n\n  }\n\n  MatAutocomplete.ɵfac = function MatAutocomplete_Factory(t) {\n    return new (t || MatAutocomplete)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MAT_AUTOCOMPLETE_DEFAULT_OPTIONS));\n  };\n\n  MatAutocomplete.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MatAutocomplete,\n    selectors: [[\"mat-autocomplete\"]],\n    contentQueries: function MatAutocomplete_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MatOption, 5);\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MatOptgroup, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.options = _t);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.optionGroups = _t);\n      }\n    },\n    viewQuery: function MatAutocomplete_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(TemplateRef, 7);\n        ɵngcc0.ɵɵviewQuery(_c0, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.template = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.panel = _t.first);\n      }\n    },\n    hostAttrs: [1, \"mat-autocomplete\"],\n    inputs: {\n      disableRipple: \"disableRipple\",\n      displayWith: \"displayWith\",\n      autoActiveFirstOption: \"autoActiveFirstOption\",\n      classList: [\"class\", \"classList\"],\n      panelWidth: \"panelWidth\"\n    },\n    outputs: {\n      optionSelected: \"optionSelected\",\n      opened: \"opened\",\n      closed: \"closed\"\n    },\n    exportAs: [\"matAutocomplete\"],\n    features: [ɵngcc0.ɵɵProvidersFeature([{\n      provide: MAT_OPTION_PARENT_COMPONENT,\n      useExisting: MatAutocomplete\n    }]), ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 0,\n    consts: [[\"role\", \"listbox\", 1, \"mat-autocomplete-panel\", 3, \"id\", \"ngClass\"], [\"panel\", \"\"]],\n    template: function MatAutocomplete_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵtemplate(0, MatAutocomplete_ng_template_0_Template, 3, 2, \"ng-template\");\n      }\n    },\n    directives: [ɵngcc1.NgClass],\n    styles: [\".mat-autocomplete-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;visibility:hidden;max-width:none;max-height:256px;position:relative;width:100%;border-bottom-left-radius:4px;border-bottom-right-radius:4px}.mat-autocomplete-panel.mat-autocomplete-visible{visibility:visible}.mat-autocomplete-panel.mat-autocomplete-hidden{visibility:hidden}.mat-autocomplete-panel-above .mat-autocomplete-panel{border-radius:0;border-top-left-radius:4px;border-top-right-radius:4px}.mat-autocomplete-panel .mat-divider-horizontal{margin-top:-1px}.cdk-high-contrast-active .mat-autocomplete-panel{outline:solid 1px}\\n\"],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  /** @nocollapse */\n\n  return MatAutocomplete;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /** @type {?} */\n  MatAutocomplete.ngAcceptInputType_autoActiveFirstOption;\n  /** @type {?} */\n\n  MatAutocomplete.ngAcceptInputType_disableRipple;\n  /**\n   * Manages active item in option list based on key events.\n   * @type {?}\n   */\n\n  MatAutocomplete.prototype._keyManager;\n  /**\n   * Whether the autocomplete panel should be visible, depending on option length.\n   * @type {?}\n   */\n\n  MatAutocomplete.prototype.showPanel;\n  /** @type {?} */\n\n  MatAutocomplete.prototype._isOpen;\n  /**\n   * \\@docs-private\n   * @type {?}\n   */\n\n  MatAutocomplete.prototype.template;\n  /**\n   * Element for the panel containing the autocomplete options.\n   * @type {?}\n   */\n\n  MatAutocomplete.prototype.panel;\n  /**\n   * \\@docs-private\n   * @type {?}\n   */\n\n  MatAutocomplete.prototype.options;\n  /**\n   * \\@docs-private\n   * @type {?}\n   */\n\n  MatAutocomplete.prototype.optionGroups;\n  /**\n   * Function that maps an option's control value to its display value in the trigger.\n   * @type {?}\n   */\n\n  MatAutocomplete.prototype.displayWith;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  MatAutocomplete.prototype._autoActiveFirstOption;\n  /**\n   * Specify the width of the autocomplete panel.  Can be any CSS sizing value, otherwise it will\n   * match the width of its host.\n   * @type {?}\n   */\n\n  MatAutocomplete.prototype.panelWidth;\n  /**\n   * Event that is emitted whenever an option from the list is selected.\n   * @type {?}\n   */\n\n  MatAutocomplete.prototype.optionSelected;\n  /**\n   * Event that is emitted when the autocomplete panel is opened.\n   * @type {?}\n   */\n\n  MatAutocomplete.prototype.opened;\n  /**\n   * Event that is emitted when the autocomplete panel is closed.\n   * @type {?}\n   */\n\n  MatAutocomplete.prototype.closed;\n  /** @type {?} */\n\n  MatAutocomplete.prototype._classList;\n  /**\n   * Unique ID to be used by autocomplete trigger's \"aria-owns\" property.\n   * @type {?}\n   */\n\n  MatAutocomplete.prototype.id;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  MatAutocomplete.prototype._changeDetectorRef;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  MatAutocomplete.prototype._elementRef;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/autocomplete/autocomplete-origin.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Directive applied to an element to make it usable\n * as a connection point for an autocomplete panel.\n */\n\n\nlet MatAutocompleteOrigin = /*#__PURE__*/(() => {\n  class MatAutocompleteOrigin {\n    /**\n     * @param {?} elementRef\n     */\n    constructor(elementRef) {\n      this.elementRef = elementRef;\n    }\n\n  }\n\n  MatAutocompleteOrigin.ɵfac = function MatAutocompleteOrigin_Factory(t) {\n    return new (t || MatAutocompleteOrigin)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  MatAutocompleteOrigin.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MatAutocompleteOrigin,\n    selectors: [[\"\", \"matAutocompleteOrigin\", \"\"]],\n    exportAs: [\"matAutocompleteOrigin\"]\n  });\n  /** @nocollapse */\n\n  return MatAutocompleteOrigin;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   * Reference to the element on which the directive is applied.\n   * @type {?}\n   */\n  MatAutocompleteOrigin.prototype.elementRef;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/autocomplete/autocomplete-trigger.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * The height of each autocomplete option.\n * @type {?}\n */\n\n\nconst AUTOCOMPLETE_OPTION_HEIGHT = 48;\n/**\n * The total height of the autocomplete panel.\n * @type {?}\n */\n\nconst AUTOCOMPLETE_PANEL_HEIGHT = 256;\n/**\n * Injection token that determines the scroll handling while the autocomplete panel is open.\n * @type {?}\n */\n\nconst MAT_AUTOCOMPLETE_SCROLL_STRATEGY = /*#__PURE__*/new InjectionToken('mat-autocomplete-scroll-strategy');\n/**\n * \\@docs-private\n * @param {?} overlay\n * @return {?}\n */\n\nfunction MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY(overlay) {\n  return (\n    /**\n    * @return {?}\n    */\n    () => overlay.scrollStrategies.reposition()\n  );\n}\n/**\n * \\@docs-private\n * @type {?}\n */\n\n\nconst MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER = {\n  provide: MAT_AUTOCOMPLETE_SCROLL_STRATEGY,\n  deps: [Overlay],\n  useFactory: MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY\n};\n/**\n * Provider that allows the autocomplete to register as a ControlValueAccessor.\n * \\@docs-private\n * @type {?}\n */\n\nconst MAT_AUTOCOMPLETE_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: /*#__PURE__*/forwardRef(\n  /**\n  * @return {?}\n  */\n  () => MatAutocompleteTrigger),\n  multi: true\n};\n/**\n * Creates an error to be thrown when attempting to use an autocomplete trigger without a panel.\n * \\@docs-private\n * @return {?}\n */\n\nfunction getMatAutocompleteMissingPanelError() {\n  return Error('Attempting to open an undefined instance of `mat-autocomplete`. ' + 'Make sure that the id passed to the `matAutocomplete` is correct and that ' + 'you\\'re attempting to open it after the ngAfterContentInit hook.');\n}\n\nlet MatAutocompleteTrigger = /*#__PURE__*/(() => {\n  class MatAutocompleteTrigger {\n    /**\n     * @param {?} _element\n     * @param {?} _overlay\n     * @param {?} _viewContainerRef\n     * @param {?} _zone\n     * @param {?} _changeDetectorRef\n     * @param {?} scrollStrategy\n     * @param {?} _dir\n     * @param {?} _formField\n     * @param {?} _document\n     * @param {?=} _viewportRuler\n     */\n    constructor(_element, _overlay, _viewContainerRef, _zone, _changeDetectorRef, scrollStrategy, _dir, _formField, _document, _viewportRuler) {\n      this._element = _element;\n      this._overlay = _overlay;\n      this._viewContainerRef = _viewContainerRef;\n      this._zone = _zone;\n      this._changeDetectorRef = _changeDetectorRef;\n      this._dir = _dir;\n      this._formField = _formField;\n      this._document = _document;\n      this._viewportRuler = _viewportRuler;\n      this._componentDestroyed = false;\n      this._autocompleteDisabled = false;\n      /**\n       * Whether or not the label state is being overridden.\n       */\n\n      this._manuallyFloatingLabel = false;\n      /**\n       * Subscription to viewport size changes.\n       */\n\n      this._viewportSubscription = Subscription.EMPTY;\n      /**\n       * Whether the autocomplete can open the next time it is focused. Used to prevent a focused,\n       * closed autocomplete from being reopened if the user switches to another browser tab and then\n       * comes back.\n       */\n\n      this._canOpenOnNextFocus = true;\n      /**\n       * Stream of keyboard events that can close the panel.\n       */\n\n      this._closeKeyEventStream = new Subject();\n      /**\n       * Event handler for when the window is blurred. Needs to be an\n       * arrow function in order to preserve the context.\n       */\n\n      this._windowBlurHandler =\n      /**\n      * @return {?}\n      */\n      () => {\n        // If the user blurred the window while the autocomplete is focused, it means that it'll be\n        // refocused when they come back. In this case we want to skip the first focus event, if the\n        // pane was closed, in order to avoid reopening it unintentionally.\n        this._canOpenOnNextFocus = this._document.activeElement !== this._element.nativeElement || this.panelOpen;\n      };\n      /**\n       * `View -> model callback called when value changes`\n       */\n\n\n      this._onChange =\n      /**\n      * @return {?}\n      */\n      () => {};\n      /**\n       * `View -> model callback called when autocomplete has been touched`\n       */\n\n\n      this._onTouched =\n      /**\n      * @return {?}\n      */\n      () => {};\n      /**\n       * Position of the autocomplete panel relative to the trigger element. A position of `auto`\n       * will render the panel underneath the trigger if there is enough space for it to fit in\n       * the viewport, otherwise the panel will be shown above it. If the position is set to\n       * `above` or `below`, the panel will always be shown above or below the trigger. no matter\n       * whether it fits completely in the viewport.\n       */\n\n\n      this.position = 'auto';\n      /**\n       * `autocomplete` attribute to be set on the input element.\n       * \\@docs-private\n       */\n\n      this.autocompleteAttribute = 'off';\n      this._overlayAttached = false;\n      /**\n       * Stream of autocomplete option selections.\n       */\n\n      this.optionSelections =\n      /** @type {?} */\n      defer(\n      /**\n      * @return {?}\n      */\n      () => {\n        if (this.autocomplete && this.autocomplete.options) {\n          return merge(...this.autocomplete.options.map(\n          /**\n          * @param {?} option\n          * @return {?}\n          */\n          option => option.onSelectionChange));\n        } // If there are any subscribers before `ngAfterViewInit`, the `autocomplete` will be undefined.\n        // Return a stream that we'll replace with the real one once everything is in place.\n\n\n        return this._zone.onStable.asObservable().pipe(take(1), switchMap(\n        /**\n        * @return {?}\n        */\n        () => this.optionSelections));\n      });\n      this._scrollStrategy = scrollStrategy;\n    }\n    /**\n     * Whether the autocomplete is disabled. When disabled, the element will\n     * act as a regular input and the user won't be able to open the panel.\n     * @return {?}\n     */\n\n\n    get autocompleteDisabled() {\n      return this._autocompleteDisabled;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set autocompleteDisabled(value) {\n      this._autocompleteDisabled = coerceBooleanProperty(value);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngAfterViewInit() {\n      if (typeof window !== 'undefined') {\n        this._zone.runOutsideAngular(\n        /**\n        * @return {?}\n        */\n        () => {\n          window.addEventListener('blur', this._windowBlurHandler);\n        });\n\n        if (_supportsShadowDom()) {\n          /** @type {?} */\n          const element = this._element.nativeElement;\n          /** @type {?} */\n\n          const rootNode = element.getRootNode ? element.getRootNode() : null; // We need to take the `ShadowRoot` off of `window`, because the built-in types are\n          // incorrect. See https://github.com/Microsoft/TypeScript/issues/27929.\n\n          this._isInsideShadowRoot = rootNode instanceof\n          /** @type {?} */\n          window.ShadowRoot;\n        }\n      }\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n\n\n    ngOnChanges(changes) {\n      if (changes['position'] && this._positionStrategy) {\n        this._setStrategyPositions(this._positionStrategy);\n\n        if (this.panelOpen) {\n          /** @type {?} */\n          this._overlayRef.updatePosition();\n        }\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      if (typeof window !== 'undefined') {\n        window.removeEventListener('blur', this._windowBlurHandler);\n      }\n\n      this._viewportSubscription.unsubscribe();\n\n      this._componentDestroyed = true;\n\n      this._destroyPanel();\n\n      this._closeKeyEventStream.complete();\n    }\n    /**\n     * Whether or not the autocomplete panel is open.\n     * @return {?}\n     */\n\n\n    get panelOpen() {\n      return this._overlayAttached && this.autocomplete.showPanel;\n    }\n    /**\n     * Opens the autocomplete suggestion panel.\n     * @return {?}\n     */\n\n\n    openPanel() {\n      this._attachOverlay();\n\n      this._floatLabel();\n    }\n    /**\n     * Closes the autocomplete suggestion panel.\n     * @return {?}\n     */\n\n\n    closePanel() {\n      this._resetLabel();\n\n      if (!this._overlayAttached) {\n        return;\n      }\n\n      if (this.panelOpen) {\n        // Only emit if the panel was visible.\n        this.autocomplete.closed.emit();\n      }\n\n      this.autocomplete._isOpen = this._overlayAttached = false;\n\n      if (this._overlayRef && this._overlayRef.hasAttached()) {\n        this._overlayRef.detach();\n\n        this._closingActionsSubscription.unsubscribe();\n      } // Note that in some cases this can end up being called after the component is destroyed.\n      // Add a check to ensure that we don't try to run change detection on a destroyed view.\n\n\n      if (!this._componentDestroyed) {\n        // We need to trigger change detection manually, because\n        // `fromEvent` doesn't seem to do it at the proper time.\n        // This ensures that the label is reset when the\n        // user clicks outside.\n        this._changeDetectorRef.detectChanges();\n      }\n    }\n    /**\n     * Updates the position of the autocomplete suggestion panel to ensure that it fits all options\n     * within the viewport.\n     * @return {?}\n     */\n\n\n    updatePosition() {\n      if (this._overlayAttached) {\n        /** @type {?} */\n        this._overlayRef.updatePosition();\n      }\n    }\n    /**\n     * A stream of actions that should close the autocomplete panel, including\n     * when an option is selected, on blur, and when TAB is pressed.\n     * @return {?}\n     */\n\n\n    get panelClosingActions() {\n      return merge(this.optionSelections, this.autocomplete._keyManager.tabOut.pipe(filter(\n      /**\n      * @return {?}\n      */\n      () => this._overlayAttached)), this._closeKeyEventStream, this._getOutsideClickStream(), this._overlayRef ? this._overlayRef.detachments().pipe(filter(\n      /**\n      * @return {?}\n      */\n      () => this._overlayAttached)) : of()).pipe( // Normalize the output so we return a consistent type.\n      map(\n      /**\n      * @param {?} event\n      * @return {?}\n      */\n      event => event instanceof MatOptionSelectionChange ? event : null));\n    }\n    /**\n     * The currently active option, coerced to MatOption type.\n     * @return {?}\n     */\n\n\n    get activeOption() {\n      if (this.autocomplete && this.autocomplete._keyManager) {\n        return this.autocomplete._keyManager.activeItem;\n      }\n\n      return null;\n    }\n    /**\n     * Stream of clicks outside of the autocomplete panel.\n     * @private\n     * @return {?}\n     */\n\n\n    _getOutsideClickStream() {\n      return merge(\n      /** @type {?} */\n      fromEvent(this._document, 'click'),\n      /** @type {?} */\n      fromEvent(this._document, 'touchend')).pipe(filter(\n      /**\n      * @param {?} event\n      * @return {?}\n      */\n      event => {\n        // If we're in the Shadow DOM, the event target will be the shadow root, so we have to\n        // fall back to check the first element in the path of the click event.\n\n        /** @type {?} */\n        const clickTarget =\n        /** @type {?} */\n        this._isInsideShadowRoot && event.composedPath ? event.composedPath()[0] : event.target;\n        /** @type {?} */\n\n        const formField = this._formField ? this._formField._elementRef.nativeElement : null;\n        return this._overlayAttached && clickTarget !== this._element.nativeElement && (!formField || !formField.contains(clickTarget)) && !!this._overlayRef && !this._overlayRef.overlayElement.contains(clickTarget);\n      }));\n    } // Implemented as part of ControlValueAccessor.\n\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    writeValue(value) {\n      Promise.resolve(null).then(\n      /**\n      * @return {?}\n      */\n      () => this._setTriggerValue(value));\n    } // Implemented as part of ControlValueAccessor.\n\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n\n\n    registerOnChange(fn) {\n      this._onChange = fn;\n    } // Implemented as part of ControlValueAccessor.\n\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n\n\n    registerOnTouched(fn) {\n      this._onTouched = fn;\n    } // Implemented as part of ControlValueAccessor.\n\n    /**\n     * @param {?} isDisabled\n     * @return {?}\n     */\n\n\n    setDisabledState(isDisabled) {\n      this._element.nativeElement.disabled = isDisabled;\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n\n\n    _handleKeydown(event) {\n      /** @type {?} */\n      const keyCode = event.keyCode; // Prevent the default action on all escape key presses. This is here primarily to bring IE\n      // in line with other browsers. By default, pressing escape on IE will cause it to revert\n      // the input value to the one that it had on focus, however it won't dispatch any events\n      // which means that the model value will be out of sync with the view.\n\n      if (keyCode === ESCAPE) {\n        event.preventDefault();\n      }\n\n      if (this.activeOption && keyCode === ENTER && this.panelOpen) {\n        this.activeOption._selectViaInteraction();\n\n        this._resetActiveItem();\n\n        event.preventDefault();\n      } else if (this.autocomplete) {\n        /** @type {?} */\n        const prevActiveItem = this.autocomplete._keyManager.activeItem;\n        /** @type {?} */\n\n        const isArrowKey = keyCode === UP_ARROW || keyCode === DOWN_ARROW;\n\n        if (this.panelOpen || keyCode === TAB) {\n          this.autocomplete._keyManager.onKeydown(event);\n        } else if (isArrowKey && this._canOpen()) {\n          this.openPanel();\n        }\n\n        if (isArrowKey || this.autocomplete._keyManager.activeItem !== prevActiveItem) {\n          this._scrollToOption();\n        }\n      }\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n\n\n    _handleInput(event) {\n      /** @type {?} */\n      let target =\n      /** @type {?} */\n      event.target;\n      /** @type {?} */\n\n      let value = target.value; // Based on `NumberValueAccessor` from forms.\n\n      if (target.type === 'number') {\n        value = value == '' ? null : parseFloat(value);\n      } // If the input has a placeholder, IE will fire the `input` event on page load,\n      // focus and blur, in addition to when the user actually changed the value. To\n      // filter out all of the extra events, we save the value on focus and between\n      // `input` events, and we check whether it changed.\n      // See: https://connect.microsoft.com/IE/feedback/details/885747/\n\n\n      if (this._previousValue !== value) {\n        this._previousValue = value;\n\n        this._onChange(value);\n\n        if (this._canOpen() && this._document.activeElement === event.target) {\n          this.openPanel();\n        }\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _handleFocus() {\n      if (!this._canOpenOnNextFocus) {\n        this._canOpenOnNextFocus = true;\n      } else if (this._canOpen()) {\n        this._previousValue = this._element.nativeElement.value;\n\n        this._attachOverlay();\n\n        this._floatLabel(true);\n      }\n    }\n    /**\n     * In \"auto\" mode, the label will animate down as soon as focus is lost.\n     * This causes the value to jump when selecting an option with the mouse.\n     * This method manually floats the label until the panel can be closed.\n     * @private\n     * @param {?=} shouldAnimate Whether the label should be animated when it is floated.\n     * @return {?}\n     */\n\n\n    _floatLabel(shouldAnimate = false) {\n      if (this._formField && this._formField.floatLabel === 'auto') {\n        if (shouldAnimate) {\n          this._formField._animateAndLockLabel();\n        } else {\n          this._formField.floatLabel = 'always';\n        }\n\n        this._manuallyFloatingLabel = true;\n      }\n    }\n    /**\n     * If the label has been manually elevated, return it to its normal state.\n     * @private\n     * @return {?}\n     */\n\n\n    _resetLabel() {\n      if (this._manuallyFloatingLabel) {\n        this._formField.floatLabel = 'auto';\n        this._manuallyFloatingLabel = false;\n      }\n    }\n    /**\n     * Given that we are not actually focusing active options, we must manually adjust scroll\n     * to reveal options below the fold. First, we find the offset of the option from the top\n     * of the panel. If that offset is below the fold, the new scrollTop will be the offset -\n     * the panel height + the option height, so the active option will be just visible at the\n     * bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop\n     * will become the offset. If that offset is visible within the panel already, the scrollTop is\n     * not adjusted.\n     * @private\n     * @return {?}\n     */\n\n\n    _scrollToOption() {\n      /** @type {?} */\n      const index = this.autocomplete._keyManager.activeItemIndex || 0;\n      /** @type {?} */\n\n      const labelCount = _countGroupLabelsBeforeOption(index, this.autocomplete.options, this.autocomplete.optionGroups);\n\n      if (index === 0 && labelCount === 1) {\n        // If we've got one group label before the option and we're at the top option,\n        // scroll the list to the top. This is better UX than scrolling the list to the\n        // top of the option, because it allows the user to read the top group's label.\n        this.autocomplete._setScrollTop(0);\n      } else {\n        /** @type {?} */\n        const newScrollPosition = _getOptionScrollPosition(index + labelCount, AUTOCOMPLETE_OPTION_HEIGHT, this.autocomplete._getScrollTop(), AUTOCOMPLETE_PANEL_HEIGHT);\n\n        this.autocomplete._setScrollTop(newScrollPosition);\n      }\n    }\n    /**\n     * This method listens to a stream of panel closing actions and resets the\n     * stream every time the option list changes.\n     * @private\n     * @return {?}\n     */\n\n\n    _subscribeToClosingActions() {\n      /** @type {?} */\n      const firstStable = this._zone.onStable.asObservable().pipe(take(1));\n      /** @type {?} */\n\n\n      const optionChanges = this.autocomplete.options.changes.pipe(tap(\n      /**\n      * @return {?}\n      */\n      () => this._positionStrategy.reapplyLastPosition()), // Defer emitting to the stream until the next tick, because changing\n      // bindings in here will cause \"changed after checked\" errors.\n      delay(0)); // When the zone is stable initially, and when the option list changes...\n\n      return merge(firstStable, optionChanges).pipe( // create a new stream of panelClosingActions, replacing any previous streams\n      // that were created, and flatten it so our stream only emits closing events...\n      switchMap(\n      /**\n      * @return {?}\n      */\n      () => {\n        /** @type {?} */\n        const wasOpen = this.panelOpen;\n\n        this._resetActiveItem();\n\n        this.autocomplete._setVisibility();\n\n        if (this.panelOpen) {\n          /** @type {?} */\n          this._overlayRef.updatePosition(); // If the `panelOpen` state changed, we need to make sure to emit the `opened`\n          // event, because we may not have emitted it when the panel was attached. This\n          // can happen if the users opens the panel and there are no options, but the\n          // options come in slightly later or as a result of the value changing.\n\n\n          if (wasOpen !== this.panelOpen) {\n            this.autocomplete.opened.emit();\n          }\n        }\n\n        return this.panelClosingActions;\n      }), // when the first closing event occurs...\n      take(1)) // set the value, close the panel, and complete.\n      .subscribe(\n      /**\n      * @param {?} event\n      * @return {?}\n      */\n      event => this._setValueAndClose(event));\n    }\n    /**\n     * Destroys the autocomplete suggestion panel.\n     * @private\n     * @return {?}\n     */\n\n\n    _destroyPanel() {\n      if (this._overlayRef) {\n        this.closePanel();\n\n        this._overlayRef.dispose();\n\n        this._overlayRef = null;\n      }\n    }\n    /**\n     * @private\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    _setTriggerValue(value) {\n      /** @type {?} */\n      const toDisplay = this.autocomplete && this.autocomplete.displayWith ? this.autocomplete.displayWith(value) : value; // Simply falling back to an empty string if the display value is falsy does not work properly.\n      // The display value can also be the number zero and shouldn't fall back to an empty string.\n\n      /** @type {?} */\n\n      const inputValue = toDisplay != null ? toDisplay : ''; // If it's used within a `MatFormField`, we should set it through the property so it can go\n      // through change detection.\n\n      if (this._formField) {\n        this._formField._control.value = inputValue;\n      } else {\n        this._element.nativeElement.value = inputValue;\n      }\n\n      this._previousValue = inputValue;\n    }\n    /**\n     * This method closes the panel, and if a value is specified, also sets the associated\n     * control to that value. It will also mark the control as dirty if this interaction\n     * stemmed from the user.\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n\n\n    _setValueAndClose(event) {\n      if (event && event.source) {\n        this._clearPreviousSelectedOption(event.source);\n\n        this._setTriggerValue(event.source.value);\n\n        this._onChange(event.source.value);\n\n        this._element.nativeElement.focus();\n\n        this.autocomplete._emitSelectEvent(event.source);\n      }\n\n      this.closePanel();\n    }\n    /**\n     * Clear any previous selected option and emit a selection change event for this option\n     * @private\n     * @param {?} skip\n     * @return {?}\n     */\n\n\n    _clearPreviousSelectedOption(skip) {\n      this.autocomplete.options.forEach(\n      /**\n      * @param {?} option\n      * @return {?}\n      */\n      option => {\n        if (option != skip && option.selected) {\n          option.deselect();\n        }\n      });\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _attachOverlay() {\n      if (!this.autocomplete) {\n        throw getMatAutocompleteMissingPanelError();\n      }\n      /** @type {?} */\n\n\n      let overlayRef = this._overlayRef;\n\n      if (!overlayRef) {\n        this._portal = new TemplatePortal(this.autocomplete.template, this._viewContainerRef);\n        overlayRef = this._overlay.create(this._getOverlayConfig());\n        this._overlayRef = overlayRef; // Use the `keydownEvents` in order to take advantage of\n        // the overlay event targeting provided by the CDK overlay.\n\n        overlayRef.keydownEvents().subscribe(\n        /**\n        * @param {?} event\n        * @return {?}\n        */\n        event => {\n          // Close when pressing ESCAPE or ALT + UP_ARROW, based on the a11y guidelines.\n          // See: https://www.w3.org/TR/wai-aria-practices-1.1/#textbox-keyboard-interaction\n          if (event.keyCode === ESCAPE || event.keyCode === UP_ARROW && event.altKey) {\n            this._resetActiveItem();\n\n            this._closeKeyEventStream.next(); // We need to stop propagation, otherwise the event will eventually\n            // reach the input itself and cause the overlay to be reopened.\n\n\n            event.stopPropagation();\n            event.preventDefault();\n          }\n        });\n\n        if (this._viewportRuler) {\n          this._viewportSubscription = this._viewportRuler.change().subscribe(\n          /**\n          * @return {?}\n          */\n          () => {\n            if (this.panelOpen && overlayRef) {\n              overlayRef.updateSize({\n                width: this._getPanelWidth()\n              });\n            }\n          });\n        }\n      } else {\n        // Update the trigger, panel width and direction, in case anything has changed.\n        this._positionStrategy.setOrigin(this._getConnectedElement());\n\n        overlayRef.updateSize({\n          width: this._getPanelWidth()\n        });\n      }\n\n      if (overlayRef && !overlayRef.hasAttached()) {\n        overlayRef.attach(this._portal);\n        this._closingActionsSubscription = this._subscribeToClosingActions();\n      }\n      /** @type {?} */\n\n\n      const wasOpen = this.panelOpen;\n\n      this.autocomplete._setVisibility();\n\n      this.autocomplete._isOpen = this._overlayAttached = true; // We need to do an extra `panelOpen` check in here, because the\n      // autocomplete won't be shown if there are no options.\n\n      if (this.panelOpen && wasOpen !== this.panelOpen) {\n        this.autocomplete.opened.emit();\n      }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _getOverlayConfig() {\n      return new OverlayConfig({\n        positionStrategy: this._getOverlayPosition(),\n        scrollStrategy: this._scrollStrategy(),\n        width: this._getPanelWidth(),\n        direction: this._dir\n      });\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _getOverlayPosition() {\n      /** @type {?} */\n      const strategy = this._overlay.position().flexibleConnectedTo(this._getConnectedElement()).withFlexibleDimensions(false).withPush(false);\n\n      this._setStrategyPositions(strategy);\n\n      this._positionStrategy = strategy;\n      return strategy;\n    }\n    /**\n     * Sets the positions on a position strategy based on the directive's input state.\n     * @private\n     * @param {?} positionStrategy\n     * @return {?}\n     */\n\n\n    _setStrategyPositions(positionStrategy) {\n      /** @type {?} */\n      const belowPosition = {\n        originX: 'start',\n        originY: 'bottom',\n        overlayX: 'start',\n        overlayY: 'top'\n      };\n      /** @type {?} */\n\n      const abovePosition = {\n        originX: 'start',\n        originY: 'top',\n        overlayX: 'start',\n        overlayY: 'bottom',\n        // The overlay edge connected to the trigger should have squared corners, while\n        // the opposite end has rounded corners. We apply a CSS class to swap the\n        // border-radius based on the overlay position.\n        panelClass: 'mat-autocomplete-panel-above'\n      };\n      /** @type {?} */\n\n      let positions;\n\n      if (this.position === 'above') {\n        positions = [abovePosition];\n      } else if (this.position === 'below') {\n        positions = [belowPosition];\n      } else {\n        positions = [belowPosition, abovePosition];\n      }\n\n      positionStrategy.withPositions(positions);\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _getConnectedElement() {\n      if (this.connectedTo) {\n        return this.connectedTo.elementRef;\n      }\n\n      return this._formField ? this._formField.getConnectedOverlayOrigin() : this._element;\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    _getPanelWidth() {\n      return this.autocomplete.panelWidth || this._getHostWidth();\n    }\n    /**\n     * Returns the width of the input element, so the panel width can match it.\n     * @private\n     * @return {?}\n     */\n\n\n    _getHostWidth() {\n      return this._getConnectedElement().nativeElement.getBoundingClientRect().width;\n    }\n    /**\n     * Resets the active item to -1 so arrow events will activate the\n     * correct options, or to 0 if the consumer opted into it.\n     * @private\n     * @return {?}\n     */\n\n\n    _resetActiveItem() {\n      this.autocomplete._keyManager.setActiveItem(this.autocomplete.autoActiveFirstOption ? 0 : -1);\n    }\n    /**\n     * Determines whether the panel can be opened.\n     * @private\n     * @return {?}\n     */\n\n\n    _canOpen() {\n      /** @type {?} */\n      const element = this._element.nativeElement;\n      return !element.readOnly && !element.disabled && !this._autocompleteDisabled;\n    }\n\n  }\n\n  MatAutocompleteTrigger.ɵfac = function MatAutocompleteTrigger_Factory(t) {\n    return new (t || MatAutocompleteTrigger)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.Overlay), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(MAT_AUTOCOMPLETE_SCROLL_STRATEGY), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.Directionality, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.MatFormField, 9), ɵngcc0.ɵɵdirectiveInject(DOCUMENT, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc5.ViewportRuler));\n  };\n\n  MatAutocompleteTrigger.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MatAutocompleteTrigger,\n    selectors: [[\"input\", \"matAutocomplete\", \"\"], [\"textarea\", \"matAutocomplete\", \"\"]],\n    hostAttrs: [1, \"mat-autocomplete-trigger\"],\n    hostVars: 7,\n    hostBindings: function MatAutocompleteTrigger_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"focusin\", function MatAutocompleteTrigger_focusin_HostBindingHandler() {\n          return ctx._handleFocus();\n        })(\"blur\", function MatAutocompleteTrigger_blur_HostBindingHandler() {\n          return ctx._onTouched();\n        })(\"input\", function MatAutocompleteTrigger_input_HostBindingHandler($event) {\n          return ctx._handleInput($event);\n        })(\"keydown\", function MatAutocompleteTrigger_keydown_HostBindingHandler($event) {\n          return ctx._handleKeydown($event);\n        });\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"autocomplete\", ctx.autocompleteAttribute)(\"role\", ctx.autocompleteDisabled ? null : \"combobox\")(\"aria-autocomplete\", ctx.autocompleteDisabled ? null : \"list\")(\"aria-activedescendant\", ctx.panelOpen && ctx.activeOption ? ctx.activeOption.id : null)(\"aria-expanded\", ctx.autocompleteDisabled ? null : ctx.panelOpen.toString())(\"aria-owns\", ctx.autocompleteDisabled || !ctx.panelOpen ? null : ctx.autocomplete == null ? null : ctx.autocomplete.id)(\"aria-haspopup\", !ctx.autocompleteDisabled);\n      }\n    },\n    inputs: {\n      position: [\"matAutocompletePosition\", \"position\"],\n      autocompleteAttribute: [\"autocomplete\", \"autocompleteAttribute\"],\n      autocompleteDisabled: [\"matAutocompleteDisabled\", \"autocompleteDisabled\"],\n      autocomplete: [\"matAutocomplete\", \"autocomplete\"],\n      connectedTo: [\"matAutocompleteConnectedTo\", \"connectedTo\"]\n    },\n    exportAs: [\"matAutocompleteTrigger\"],\n    features: [ɵngcc0.ɵɵProvidersFeature([MAT_AUTOCOMPLETE_VALUE_ACCESSOR]), ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  /** @nocollapse */\n\n  return MatAutocompleteTrigger;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /** @type {?} */\n  MatAutocompleteTrigger.ngAcceptInputType_autocompleteDisabled;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  MatAutocompleteTrigger.prototype._overlayRef;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  MatAutocompleteTrigger.prototype._portal;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  MatAutocompleteTrigger.prototype._componentDestroyed;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  MatAutocompleteTrigger.prototype._autocompleteDisabled;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  MatAutocompleteTrigger.prototype._scrollStrategy;\n  /**\n   * Old value of the native input. Used to work around issues with the `input` event on IE.\n   * @type {?}\n   * @private\n   */\n\n  MatAutocompleteTrigger.prototype._previousValue;\n  /**\n   * Strategy that is used to position the panel.\n   * @type {?}\n   * @private\n   */\n\n  MatAutocompleteTrigger.prototype._positionStrategy;\n  /**\n   * Whether or not the label state is being overridden.\n   * @type {?}\n   * @private\n   */\n\n  MatAutocompleteTrigger.prototype._manuallyFloatingLabel;\n  /**\n   * The subscription for closing actions (some are bound to document).\n   * @type {?}\n   * @private\n   */\n\n  MatAutocompleteTrigger.prototype._closingActionsSubscription;\n  /**\n   * Subscription to viewport size changes.\n   * @type {?}\n   * @private\n   */\n\n  MatAutocompleteTrigger.prototype._viewportSubscription;\n  /**\n   * Whether the autocomplete can open the next time it is focused. Used to prevent a focused,\n   * closed autocomplete from being reopened if the user switches to another browser tab and then\n   * comes back.\n   * @type {?}\n   * @private\n   */\n\n  MatAutocompleteTrigger.prototype._canOpenOnNextFocus;\n  /**\n   * Whether the element is inside of a ShadowRoot component.\n   * @type {?}\n   * @private\n   */\n\n  MatAutocompleteTrigger.prototype._isInsideShadowRoot;\n  /**\n   * Stream of keyboard events that can close the panel.\n   * @type {?}\n   * @private\n   */\n\n  MatAutocompleteTrigger.prototype._closeKeyEventStream;\n  /**\n   * Event handler for when the window is blurred. Needs to be an\n   * arrow function in order to preserve the context.\n   * @type {?}\n   * @private\n   */\n\n  MatAutocompleteTrigger.prototype._windowBlurHandler;\n  /**\n   * `View -> model callback called when value changes`\n   * @type {?}\n   */\n\n  MatAutocompleteTrigger.prototype._onChange;\n  /**\n   * `View -> model callback called when autocomplete has been touched`\n   * @type {?}\n   */\n\n  MatAutocompleteTrigger.prototype._onTouched;\n  /**\n   * The autocomplete panel to be attached to this trigger.\n   * @type {?}\n   */\n\n  MatAutocompleteTrigger.prototype.autocomplete;\n  /**\n   * Position of the autocomplete panel relative to the trigger element. A position of `auto`\n   * will render the panel underneath the trigger if there is enough space for it to fit in\n   * the viewport, otherwise the panel will be shown above it. If the position is set to\n   * `above` or `below`, the panel will always be shown above or below the trigger. no matter\n   * whether it fits completely in the viewport.\n   * @type {?}\n   */\n\n  MatAutocompleteTrigger.prototype.position;\n  /**\n   * Reference relative to which to position the autocomplete panel.\n   * Defaults to the autocomplete trigger element.\n   * @type {?}\n   */\n\n  MatAutocompleteTrigger.prototype.connectedTo;\n  /**\n   * `autocomplete` attribute to be set on the input element.\n   * \\@docs-private\n   * @type {?}\n   */\n\n  MatAutocompleteTrigger.prototype.autocompleteAttribute;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  MatAutocompleteTrigger.prototype._overlayAttached;\n  /**\n   * Stream of autocomplete option selections.\n   * @type {?}\n   */\n\n  MatAutocompleteTrigger.prototype.optionSelections;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  MatAutocompleteTrigger.prototype._element;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  MatAutocompleteTrigger.prototype._overlay;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  MatAutocompleteTrigger.prototype._viewContainerRef;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  MatAutocompleteTrigger.prototype._zone;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  MatAutocompleteTrigger.prototype._changeDetectorRef;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  MatAutocompleteTrigger.prototype._dir;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  MatAutocompleteTrigger.prototype._formField;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  MatAutocompleteTrigger.prototype._document;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  MatAutocompleteTrigger.prototype._viewportRuler;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/autocomplete/autocomplete-module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet MatAutocompleteModule = /*#__PURE__*/(() => {\n  class MatAutocompleteModule {}\n\n  MatAutocompleteModule.ɵfac = function MatAutocompleteModule_Factory(t) {\n    return new (t || MatAutocompleteModule)();\n  };\n\n  MatAutocompleteModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MatAutocompleteModule\n  });\n  MatAutocompleteModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER],\n    imports: [[MatOptionModule, OverlayModule, MatCommonModule, CommonModule], MatOptionModule, MatCommonModule]\n  });\n  return MatAutocompleteModule;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MatAutocompleteModule, {\n    declarations: function () {\n      return [MatAutocomplete, MatAutocompleteTrigger, MatAutocompleteOrigin];\n    },\n    imports: function () {\n      return [MatOptionModule, OverlayModule, MatCommonModule, CommonModule];\n    },\n    exports: function () {\n      return [MatAutocomplete, MatOptionModule, MatAutocompleteTrigger, MatAutocompleteOrigin, MatCommonModule];\n    }\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: src/material/autocomplete/public-api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { AUTOCOMPLETE_OPTION_HEIGHT, AUTOCOMPLETE_PANEL_HEIGHT, MAT_AUTOCOMPLETE_DEFAULT_OPTIONS, MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY, MAT_AUTOCOMPLETE_SCROLL_STRATEGY, MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY, MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER, MAT_AUTOCOMPLETE_VALUE_ACCESSOR, MatAutocomplete, MatAutocompleteModule, MatAutocompleteOrigin, MatAutocompleteSelectedEvent, MatAutocompleteTrigger, getMatAutocompleteMissingPanelError }; //# sourceMappingURL=autocomplete.js.map","map":null,"metadata":{},"sourceType":"module"}